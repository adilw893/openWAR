<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Data Acquisition</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Introduction to openWAR}
-->

<h3>Data Acquisition</h3>

<p>We have developed an R package to compute our implementation of WAR. The first step in that process is to get meaningful play-by-play data. We have written parsers that will download and extract data from the Major League Baseball Advanced Media (MLBAM) GameDay server. This data is updated live, and available to the public. Thus, although this data is not &ldquo;free as in freedom&rdquo;, it is &ldquo;free as in beer.&rdquo; </p>

<p>Using our <strong>openWAR</strong> package, a single game&#39;s worth of play-by-play data can be retrieved from the GameDay servers and processed into a data frame. The R class <strong>gameday</strong> contains an object that includes the relevant URLs and XML files, as well as the processed data. The XML files and processed data are cached locally for faster retrieval. Note that since the MLBAM data is not transferrable, all data must be downloaded by the user at least once. </p>

<pre><code class="r">require(openWAR)
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;mosaic::do&#39; when loading &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;mosaic::tally&#39; when loading
## &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;mosaic::count&#39; when loading
## &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;stringr::%&gt;%&#39; when loading &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;dplyr::do&#39; when loading &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;dplyr::group_by&#39; when loading
## &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;dplyr::mutate&#39; when loading
## &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;dplyr::summarize&#39; when loading
## &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;stringr::str_count&#39; when loading
## &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning: replacing previous import by &#39;stringr::str_split&#39; when loading
## &#39;openWAR&#39;
</code></pre>

<pre><code>## Warning in .registerS3method(fin[i, 1], fin[i, 2], fin[i, 3], fin[i, 4], :
## 重新啟動插斷的約定求值
</code></pre>

<pre><code>## Warning in get(method, envir = home): 重新啟動插斷的約定求值
</code></pre>

<pre><code>## Warning in get(method, envir = home): internal error -3 in R_decompress1
</code></pre>

<pre><code class="r">gd = gameday()
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;gameday&quot;
</code></pre>

<pre><code class="r"># Equivalently
data(MetsBraves)
</code></pre>

<pre><code>## Warning in data(MetsBraves): data set &#39;MetsBraves&#39; not found
</code></pre>

<h4>Single Game data</h4>

<p>The default game was played on August 12th, 2012 between the New York Mets and the Atlanta Braves. </p>

<pre><code class="r">gd$gameId
</code></pre>

<pre><code>## [1] &quot;gid_2012_08_12_atlmlb_nynmlb_1&quot;
</code></pre>

<p>The directory on the GameDay server that contains that actual XML files is located here.</p>

<pre><code class="r">gd$base
</code></pre>

<pre><code>## [1] &quot;http://gd2.mlb.com/components/game/mlb/year_2012/month_08/day_12/&quot;
</code></pre>

<p>In this game, the Braves beat the Mets, 6-5.</p>

<pre><code class="r">summary(gd)
</code></pre>

<pre><code>##        Length Class  Mode     
## gameId 1      -none- character
## base   1      -none- character
## url    5      -none- character
</code></pre>

<p>Our primary interest will be in analyzing the play-by-play data that we have processed for this game. This data contains a complete record of what happened in the game. For example, this game started with Michael Bourn leading off with a double. After a walk to Martin Prado and a strikeout of Jason Heyward, Chipper Jones grounded into an inning-ending 5-4-3 double play. </p>

<pre><code class="r">head(gd$ds)
</code></pre>

<pre><code>## NULL
</code></pre>

<h4>Many games</h4>

<p>More often, we&#39;ll be interested in investigated data from many games. The function <strong>getData()</strong> will load (or download) data over any time interval in which you are interested. Let&#39;s figure out how many home runs were hit on May 14th, 2013. </p>

<pre><code class="r">ds = getData(start = &quot;2013-05-14&quot;)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;getData&quot;
</code></pre>

<pre><code class="r">subset(ds, event == &quot;Home Run&quot;, select = c(&quot;gameId&quot;, &quot;batterId&quot;, &quot;description&quot;))
</code></pre>

<pre><code>## Error in subset(ds, event == &quot;Home Run&quot;, select = c(&quot;gameId&quot;, &quot;batterId&quot;, : 找不到物件 &#39;ds&#39;
</code></pre>

<h4>Visualizing the data</h4>

<p>The best part about the MLBAM data is that it contains an \((x,y)\)-coordinate indicated the location of each batted ball hit into play. We can visualize this. </p>

<pre><code class="r">plot(data = ds)
</code></pre>

<pre><code>## Error in plot(data = ds): 找不到物件 &#39;ds&#39;
</code></pre>

<h3>Modeling</h3>

<p>In order to compute <strong>openWAR</strong>, we need to model several quantities. The first thing we need to understand is the relative value of each &ldquo;state&rdquo; of a half-inning. Since there are three bases, each of which can be either occupied or unoccupied, and there are three possible numbers of outs, each plate appearance begins with the half-inning in one of 25 possible states (the 24 states, plus one last state for three outs). We would like to assign a value to each one of these states that indicates the expected number of runs that will be scored in the remainder of that half-inning. We have precomputed the states and the number of <strong>futureRuns</strong> associated with each play. </p>

<p>Thus, we want to fit the model
\[
  futureRuns \sim baseCode + outs + baseCode \cdot outs,
\]
where \(baseCode\) is a description of the configuration of the baserunners, and \(outs\) is the number of outs in the half-inning. </p>

<p>For example, consider the bottom of the 1st inning of our game:</p>

<pre><code class="r">subset(gd$ds, inning == 1 &amp; half == &quot;bottom&quot;, select=c(&quot;runsFuture&quot;, &quot;runsOnPlay&quot;, &quot;startCode&quot;, &quot;startOuts&quot;, &quot;description&quot;))
</code></pre>

<pre><code>## Error in subset.default(gd$ds, inning == 1 &amp; half == &quot;bottom&quot;, select = c(&quot;runsFuture&quot;, : 找不到物件 &#39;inning&#39;
</code></pre>

<p>The Mets scored two runs in the inning, and thus, when Ruben Tejada opened the inning, there were no runners on base, no outs, but two \(futureRuns\) were associated with this play. After Tejada flew out, there was one out, but still no one on base and two \(futureRuns\). After Mike Baxter singles, David Wright came to the plate with a runner on first (bc_before = 1), one out, and two \(futureRuns\). His double scored one run, so Ike Davis followed with a runner on third, one out, and now only one \(futureRuns\). By the time Daniel Murphy bats, there are no further \(futureRuns\) in the inning. </p>

<p>Every inning begins with no one on and no one out. In this example, two runs scored in the inning. By averaging over all innings, we create an estimate of the expected \(futureRuns\) for the state \((0,0)\). But we can just as easily do the same for all states. </p>

<h4>Building a model for expected runs</h4>

<p>The simplest way to build a model for \(futureRuns\) is to take the average over all observations. To do this, we&#39;ll need more data. </p>

<pre><code class="r"># Will take a loooong time -- the first time
# ds = getDataWeekly(&quot;2013-04-01&quot;)
# ds = getDataWeekly(&quot;2013-04-08&quot;)
# ds = getDataWeekly(&quot;2013-04-15&quot;)
# ds = getDataWeekly(&quot;2013-04-22&quot;)
# ds = getData(&quot;2013-03-31&quot;)
# 2013 first half
# ds = getData(&quot;2013-03-31&quot;, end=&quot;2013-07-14&quot;)

# ds = getDataMonthly(2013, 6)
# MLBAM2013 = ds
# save(MLBAM2013, file=&quot;data/MLBAM2013.rda&quot;)
data(MLBAM2013)
</code></pre>

<pre><code>## Warning in data(MLBAM2013): data set &#39;MLBAM2013&#39; not found
</code></pre>

<pre><code class="r">ds = MLBAM2013
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 找不到物件 &#39;MLBAM2013&#39;
</code></pre>

<p>For example, consider the half inning we visited previously. </p>

<pre><code class="r">subset(gd$ds, inning == 1 &amp; half == &quot;bottom&quot;, select=c(&quot;runsFuture&quot;, &quot;runsOnPlay&quot;, &quot;startCode&quot;, &quot;startOuts&quot;, &quot;description&quot;))
</code></pre>

<pre><code>## Error in subset.default(gd$ds, inning == 1 &amp; half == &quot;bottom&quot;, select = c(&quot;runsFuture&quot;, : 找不到物件 &#39;inning&#39;
</code></pre>

<p>The inning began in the state \((0,0)\). Our estimate \(\hat{\rho}(0,0)\) of the expected value (in runs) of that state is:</p>

<pre><code class="r">fit.rem = getRunEx(ds)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;getRunEx&quot;
</code></pre>

<pre><code class="r">fit.rem(baseCode = 0, outs = 0)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<pre><code class="r"># Note this is equivalent to 
# rem[1,1]
</code></pre>

<p>On the first play of the inning, Ruben Tejada flied out. This moved the inning into the state \((0,1)\), since there were still no runners on base, but now there was one out. The value of this state is </p>

<pre><code class="r">fit.rem(0,1)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<p>The difference between these two states is \(\hat{\delta}_i\):</p>

<pre><code class="r">fit.rem(0,1) - fit.rem(0,0)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<p>In modeling this play, our goal is to apportion the value of \(\hat{\delta}_i\) to each of the offensive players. In this case, Tejada was the only offensive player involved, so he gets the full amount. Moreover, \(-\hat{\delta}_i\) must also be attributed to the defense. In this case, some of that credit will go to the pitcher, and some will go to the centerfielder. The details of this apportionment scheme will be revealed later. </p>

<p>The second batter, Mike Baxter, singled. This moved the inning from \((0,1)\) to \((1, 1)\). Accordingly, Baxter would receive:</p>

<pre><code class="r">fit.rem(1,1) - fit.rem(0,1)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<p>So far, so good. The next play is particularly complicated. David Wright doubles homes Baxter, and then advances to third on a throwing error by the rightfielder. Let&#39;s assume for a moment that the error didn&#39;t happen, and that Wright end the play on second base. In this case, the ending state is \((2,1)\), but in addition, one run scored. Thus, the change in expected runs is:</p>

<pre><code class="r">fit.rem(2,1) - fit.rem(1,1) + 1
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<p>Clearly, much of the credit here should go to Wright, for hitting the double. But what about Baxter, who scored from first on a double? Our plan is to assume &ldquo;ghostrunner&rdquo; rules, wherein the number of bases advanced by each baserunner is determined by the type of hit. Since Wright hit a double, Baxter should have advanced two bases, leaving the inning in the state \((6,1)\). The additional base that he advanced (from third to home) should then be given to Baxter. Thus, as a batter, Wright accrues:</p>

<pre><code class="r">fit.rem(6,1) - fit.rem(1,1)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<p>While Baxter accrues the remainder:</p>

<pre><code class="r">fit.rem(2,1) - fit.rem(6,1) + 1
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<p>But now let&#39;s revisit what actually happened. Heyward&#39;s error allowed Wright to move to third. Thus, the state before the error occurred was \((2,1)\) and it led to \((4,1)\). The difference</p>

<pre><code class="r">fit.rem(4,1) - fit.rem(2,1)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): 沒有這個函數 &quot;fit.rem&quot;
</code></pre>

<p>goes to Heyward as a rightfielder, and Wright as a baserunner. </p>

</body>

</html>
