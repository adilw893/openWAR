
OpenWAR
=======

Our goal is to build a fully open-source implementation of Wins Above Replacement (WAR). 

### Motivation

### Data Acquisition

We have developed an R package to compute our implementation of WAR. The first step in that process is to get meaningful play-by-play data. We have written parsers that will download and extract data from the Major League Baseball Advanced Media (MLBAM) GameDay server. This data is updated live, and available to the public. Thus, although this data is not "free as in freedom", it is "free as in beer." 

Using our **openWAR** package, a single game's worth of play-by-play data can be retrieved from the GameDay servers and processed into a data frame. The R class **gameday** contains an object that includes the relevant URLs and XML files, as well as the processed data. The XML files and processed data are cached locally for faster retrieval. Note that since the MLBAM data is not transferrable, all data must be downloaded by the user at least once. 

```{r, message=FALSE}
require(openWAR)
gd = gameday()
# Equivalently
data(MetsBraves)
```

#### Single Game data

The default game was played on August 12th, 2012 between the New York Mets and the Atlanta Braves. 

```{r}
gd$gameId
```

The directory on the GameDay server that contains that actual XML files is located here.

```{r}
gd$base
```

In this game, the Braves beat the Mets, 6-5.

```{r}
summary(gd)
```

Our primary interest will be in analyzing the play-by-play data that we have processed for this game. This data contains a complete record of what happened in the game. For example, this game started with Michael Bourn leading off with a double. After a walk to Martin Prado and a strikeout of Jason Heyward, Chipper Jones grounded into an inning-ending 5-4-3 double play. 

```{r}
head(gd$ds)
```

#### Many games

More often, we'll be interested in investigated data from many games. The function **getData()** will load (or download) data over any time interval in which you are interested. Let's figure out how many home runs were hit on May 14th, 2013. 

```{r may14, message=FALSE, warning=FALSE}
ds = getData(start = "2013-05-14")
subset(ds, event == "Home Run", select = c("gameId", "batterId", "description"))
```

#### Visualizing the data

The best part about the MLBAM data is that it contains an $(x,y)$-coordinate indicated the location of each batted ball hit into play. We can visualize this. 

```{r, message=FALSE}
bbplot(data = ds)
```

### Modeling

In order to compute **openWAR**, we need to model several quantities. The first thing we need to understand is the relative value of each "state" of a half-inning. Since there are three bases, each of which can be either occupied or unoccupied, and there are three possible numbers of outs, each plate appearance begins with the half-inning in one of 25 possible states (the 24 states, plus one last state for three outs). We would like to assign a value to each one of these states that indicates the expected number of runs that will be scored in the remainder of that half-inning. We have precomputed the states and the number of **futureRuns** associated with each play. 

Thus, we want to fit the model
$$
  futureRuns \sim baseCode + outs + baseCode \cdot outs,
$$
where $baseCode$ is a description of the configuration of the baserunners, and $outs$ is the number of outs in the half-inning. 

For example, consider the bottom of the 1st inning of our game:

```{r}
subset(gd$ds, inning == 1 & half == "bottom", select=c("runsFuture", "runsOnPlay", "startCode", "startOuts", "description"))
```

The Mets scored two runs in the inning, and thus, when Ruben Tejada opened the inning, there were no runners on base, no outs, but two $futureRuns$ were associated with this play. After Tejada flew out, there was one out, but still no one on base and two $futureRuns$. After Mike Baxter singles, David Wright came to the plate with a runner on first (bc_before = 1), one out, and two $futureRuns$. His double scored one run, so Ike Davis followed with a runner on third, one out, and now only one $futureRuns$. By the time Daniel Murphy bats, there are no further $futureRuns$ in the inning. 

Every inning begins with no one on and no one out. In this example, two runs scored in the inning. By averaging over all innings, we create an estimate of the expected $futureRuns$ for the state $(0,0)$. But we can just as easily do the same for all states. 

#### Building a model for expected runs

The simplest way to build a model for $futureRuns$ is to take the average over all observations. To do this, we'll need more data. 

```{r, message=FALSE, eval=TRUE}
# Will take a loooong time -- the first time
# ds = getWeeklyData("2013-04-01")
# ds = getWeeklyData("2013-04-08")
# ds = getWeeklyData("2013-04-15")
# ds = getWeeklyData("2013-04-22")
# ds = getData("2013-03-31")
# 2013 first half
# ds = getData("2013-03-31", end="2013-07-14")

# ds = getMonthlyData(2013, 6)
# MLBAM2013 = ds
# save(MLBAM2013, file="data/MLBAM2013.rda")
data(MLBAM2013)
ds = MLBAM2013
```

First, some basic accounting to make sure that our data is accurate. Compare these with [Baseball-reference.com](http://www.baseball-reference.com/leagues/MLB/2013-standard-batting.shtml)

```{r}
sort(tally(~event, data=ds), decreasing=TRUE)
ds$bat_team = with(ds, ifelse(half == "top", as.character(away_team), as.character(home_team)))
teams = ddply(ds, ~ bat_team, summarise, G = length(unique(gameId)), PA = sum(isPA), R = sum(runsOnPlay), H = sum(isHit), HR = sum(event == "Home Run"), K = sum(event %in% c("Strikeout", "Strikeout - DP")), OBP = sum(isHit | event %in% c("Walk", "Intent Walk", "Hit By Pitch")) / sum(isPA & !event %in% c("Sac Bunt", "Sacrifice Bunt DP")))
teams[order(teams$PA, decreasing=TRUE),]
```

These numbers are *very* close. 

In this case we have ``r nrow(ds)`` observations. However, not all of these innings were completed, due to walk-offs. By including these innings, we would be underestimating the expected run values, since those walk-off innings score fewer runs than they potentially could have. 

```{r}
walk.offs = ddply(subset(ds, outsInInning < 3, select=c("gameId", "inning", "half")), ~gameId + inning + half, nrow)
walk.offs
```

There were ``r length(walk.offs)``, all of which occurred in the bottom of an inning after the 8th. Let's remove these half-innings

```{r}
ds.complete = subset(ds, outsInInning == 3)
```


These break down by state as follows:

```{r}
rmod1 = favstats(runsFuture ~ as.factor(startCode) + as.factor(startOuts), data=ds.complete)
rmod1
```

The number of complete innings is:

```{r}
N = nrow(unique(ds.complete[,c("gameId", "inning", "half")]))
N
nrow(subset(ds.complete, startCode == 0 & startOuts == 0 & runsITD == 0))
nrow(subset(ds.complete, endCode == 0 & endOuts == 3))
```

Thus, in our naive model for $runsFuture$, the value of the state $(0,0)$ is:

```{r}
rmod1$mean[1]
```



Alternatively, consider a regression model for $runsFuture$ as a function of $baseCode$ and $outs$ and their interaction:

```{r, eval=TRUE}
rmod2 = lm(runsFuture ~ as.factor(startCode) * as.factor(startOuts), data=ds.complete)
summary(rmod2)
```

We can use this model to recover a Run Expectancy Matrix, similar to [this one](http://www.baseballprospectus.com/sortable/index.php?cid=1091223) computed by Baseball Prospectus from 2012. 

> Note that our notation for the baseCode is different from theirs. 

```{r}
states = expand.grid(startCode = 0:7, startOuts = 0:2)
states = transform(states, runs = predict(rmod2, newdata=states))
rem = matrix(states$runs, ncol = 3, dimnames=list(0:7, 0:2))
rem
```

Compare these figures with the empirical estimates

```{r}
matrix(rmod1$mean, ncol = 3, dimnames=list(0:7, 0:2))
```

The coefficients are the same, but the regression framework gives us a principled way to address the error in these estimates. We can also visualize our model. 

```{r}
xyplot(jitter(runsFuture) ~ jitter(startCode), groups=startOuts, data=ds.complete
       , alpha = 0.3, pch = 19
       , auto.key=list(columns = 3)
       , xlab="Base Code before Plate Appearance"
       , ylab="Runs Following Plate Appearance"
)
palette = trellis.par.get("superpose.symbol")$col
ladd(panel.lines(row.names(rem), rem[,1], col = palette[1], lwd = 3))
ladd(panel.lines(row.names(rem), rem[,2], col = palette[2], lwd = 3))
ladd(panel.lines(row.names(rem), rem[,3], col = palette[3], lwd = 3))
```

We note that in general, each higher $baseCode$ is associated with a larger number of expected $futureRuns$, holding the number of $outs$ constant. We can see this more clearly by looking simply at the model estimates. 

```{r}
xyplot(runs ~ startCode, groups=startOuts, data=states
       , type=c("p", "l"), auto.key=list(columns = 3)
       , xlab="Base Code before Plate Appearance"
       , ylab="Expected Runs Following Plate Appearance"
)
```

It is also instructive to examine the distribution of runs scored **on** (not $futureRuns$, but rather $runsOnPlay$) a particular plate appearance. 

```{r}
xyplot(jitter(runsOnPlay) ~ jitter(startCode), groups=startOuts, data=ds.complete
       , auto.key=list(columns = 3)
       , xlab="Base Code before Plate Appearance"
       , ylab="Runs Generated by Plate Appearance"
)
```

#### Modeling Offense

We employ the notion of **conservation of runs**. That is, every run gained by the offense is a run lost by the defense. Thus, our first task is to determine, for each play, how many *expected* runs were gained by the offensive team. The defensive team must have lost that same number of *expected* runs. Let $r_i$ be actual number of runs scored on the $i^{th}$ play, and $\rho(b,o)$ be the true expected value of the state $(b,o)$. Then we define 
$$
  \delta_i = \rho(b_{i+1},o_{i+1}) - \rho(b_i,o_i) + r_{i}
$$
to be the true number of expected runs gained on the $i^{th}$ play. We stress that this quantity is unknown, since we can only estimate the true expected value associated with each $(base, out)$ state. 

For example, consider the half inning we visited previously. 

```{r}
subset(gd$ds, inning == 1 & half == "bottom", select=c("runsFuture", "runsOnPlay", "startCode", "startOuts", "description"))
```

The inning began in the state $(0,0)$. Our estimate $\hat{\rho}(0,0)$ of the expected value (in runs) of that state is:

```{r}
fit.rem = makeFun(rmod2)
fit.rem(startCode = 0, startOuts = 0)
# Note this is equivalent to 
# rem[1,1]
```

On the first play of the inning, Ruben Tejada flied out. This moved the inning into the state $(0,1)$, since there were still no runners on base, but now there was one out. The value of this state is 

```{r}
fit.rem(0,1)
```

The difference between these two states is $\hat{\delta}_i$:

```{r}
fit.rem(0,1) - fit.rem(0,0)
```

In modeling this play, our goal is to apportion the value of $\hat{\delta}_i$ to each of the offensive players. In this case, Tejada was the only offensive player involved, so he gets the full amount. Moreover, $-\hat{\delta}_i$ must also be attributed to the defense. In this case, some of that credit will go to the pitcher, and some will go to the centerfielder. The details of this apportionment scheme will be revealed later. 

The second batter, Mike Baxter, singled. This moved the inning from $(0,1)$ to $(1, 1)$. Accordingly, Baxter would receive:

```{r}
fit.rem(1,1) - fit.rem(0,1)
```

So far, so good. The next play is particularly complicated. David Wright doubles homes Baxter, and then advances to third on a throwing error by the rightfielder. Let's assume for a moment that the error didn't happen, and that Wright end the play on second base. In this case, the ending state is $(2,1)$, but in addition, one run scored. Thus, the change in expected runs is:

```{r}
fit.rem(2,1) - fit.rem(1,1) + 1
```

Clearly, much of the credit here should go to Wright, for hitting the double. But what about Baxter, who scored from first on a double? Our plan is to assume "ghostrunner" rules, wherein the number of bases advanced by each baserunner is determined by the type of hit. Since Wright hit a double, Baxter should have advanced two bases, leaving the inning in the state $(6,1)$. The additional base that he advanced (from third to home) should then be given to Baxter. Thus, as a batter, Wright accrues:

```{r}
fit.rem(6,1) - fit.rem(1,1)
```

While Baxter accrues the remainder:

```{r}
fit.rem(2,1) - fit.rem(6,1) + 1
```

But now let's revisit what actually happened. Heyward's error allowed Wright to move to third. Thus, the state before the error occurred was $(2,1)$ and it led to $(4,1)$. The difference

```{r}
fit.rem(4,1) - fit.rem(2,1)
```

goes to Heyward as a rightfielder, and Wright as a baserunner. 

Here is the function that will the "ghostrunner" state:

```{r}
ghostrunnerExR = function (startCode, startOuts, event) {
  if (event == "Home Run") {
    endCode = (startCode * 2^4) %% 8
    outs = 0
    runs = sum(as.numeric(intToBits(startCode))) + 1
  } else if (event == "Triple") {
    endCode = (startCode * 2^3 + 4) %% 8
    outs = 0
    runs = sum(as.numeric(intToBits(startCode)))
  } else if (event == "Double") {
    endCode = (startCode * 2^2 + 2) %% 8
    outs = 0
    if (startCode >= 6) { 
      runs = 2
    } else if (startCode >= 2) { 
      runs = 1
    } else {
      runs = 0
    }
  } else if (event == "Single") {
    endCode = (startCode * 2^1 + 1) %% 8
    outs = 0
    if (startCode >= 4) { 
      runs = 1
    } else {
      runs = 0
    }
  } else if (event %in% c("Walk", "Intentional Walk", "Hit By Pitch")) {
    endCode = (startCode + 1) %% 8
    outs = 0
    if (startCode == 7) { 
      runs = 1
    } else {
      runs = 0
    }
  } else if (event %in% c("Grounded Into DP")) {
    endCode = startCode
    outs = 2
    if (startCode >= 4) { 
      runs = 1
    } else {
      runs = 0
    }
  } else { 
    endCode = startCode
    outs = 1
    runs = 0
  }
  endOuts = startOuts + outs
  if (endOuts == 3) {
    endExR = 0
  } else {
    endExR = fit.rem(endCode, endOuts)
  }
  return(endExR - fit.rem(startCode, startOuts) + runs)
}
```


So what does this look like? First, let's assign the beginning and ending state to each play.

```{r}
ds = transform(ds, startExR = fit.rem(startCode, startOuts))
# a hack because fit.rem can't handle three out states
tempEndOuts = ifelse(ds$endOuts == 3, 0, ds$endOuts)
ds$endExR = ifelse(ds$endOuts == 3, 0, fit.rem(ds$endCode, tempEndOuts))
ds = transform(ds, delta = endExR - startExR + runsOnPlay)
```

Let's build a model based on the location of the hit

```{r}
# mod.bat = lm(delta ~ poly(our.x, 2) + poly(our.y, 2) + event, data=ds)
```

```{r}
# ds$delta.bat = mapply(ghostrunnerExR, ds$startCode, ds$startOuts, ds$event)
```

One of the nice features of this type of model is that in $n$ completed innings, the number of expected runs generated should be exactly equal to the number of runs scored. 

$$
  \sum_{j \in innings} \sum_{i \in plays} \delta_{i}^j = \sum_{j \in innings} \sum_{i \in plays} \rho^j(b_{i+1}, o_{i+1}) - \rho^j(b_{i}, o_{i}) + r_{i}^j 
$$
$$
  = \sum_{j \in innings} \rho (0, 3) - \rho (0,0) + \sum_{i \in plays} r_i^j = - n \cdot \rho(0,0) + \sum_{j \in innings} \sum_{i \in plays} r_i^j
$$
This leads us to the estimate that
$$
  \hat{\rho}(0,0) = \frac{1}{n} \sum_{j \in innings} \sum_{i \in plays} r_i^j
$$

If runs are conserved, then the sum of all of the $\delta_i$'s should be zero.

```{r}
ds.complete = subset(ds, outsInInning == 3)
sum(ds.complete$delta)
```

Moreover, the total number of runs scored should match the product of the number of completed innings times $\hat{\rho}(0,0)$. 

```{r}
sum(ds.complete$runsOnPlay)
N * fit.rem(0,0)
```

Note that the runs are not equally distributed across innings. 

```{r, message=FALSE}
require(plyr)
ddply(ds, ~ inning, summarise, N = length(inning), G = length(unique(gameId)), D = sum(delta, na.rm=TRUE))
```

#### Estimating Batting WAR

We're now in a position where we can compute the batting component of WAR. 

Now we need a model that describes the expected performance of the batter. This model gives the expected changed in run scoring associated with the event type, after controlling for ballpark and the platoon advantage. The output of this model is the component that will go to the batter. 

```{r}
mod.bat = lm(delta ~ event + stadium + (stand == throws), data=ds)
summary(mod.bat)
```

This is a flat model that controls only for ballpark and the platoon advantage.

```{r}
ds = transform(ds, delta.bat = mod.bat$fitted)
war.bat = ddply(ds, ~ batterId, summarise, Name = max(as.character(batterName)), PA = length(batterId), G = length(unique(gameId)), HR = sum(event=="Home Run"), RAA = sum(delta, na.rm=TRUE), RAA.bat = sum(delta.bat, na.rm=TRUE))
```

Who are the batting WAR leaders?

```{r}
war.bat[order(war.bat$RAA.bat, decreasing=TRUE),]
densityplot(~RAA.bat, data=war.bat)
```

This makes a lot of sense. 

```{r}
dw = subset(ds, batterId == 431151)
dw[order(dw$delta, decreasing=TRUE),c("event", "startCode", "endCode", "startOuts", "endOuts", "runsOnPlay", "startExR", "endExR", "delta", "delta.bat")]
```

#### Estimating Baserunning WAR

Now, we need to partition $\delta$ among the (at most) four offensive players. We have already attributed the first (and usually largest) piece to the batter. For this iteration we'll simply split up the remainder equally among the baserunners. 

```{r}
ds = transform(ds, delta.br = delta - delta.bat)
xhistogram(~delta.br, data=ds)
subset(ds, delta.br > 2)
ds$delta.br1 = with(ds, ifelse(!is.na(start1B), delta.br / (1 * !is.na(c("start1B", "start2B", "start3B"))) %*% c(1, 1, 1), NA))
ds$delta.br2 = with(ds, ifelse(!is.na(start2B), delta.br / (1 * !is.na(c("start1B", "start2B", "start3B"))) %*% c(1, 1, 1), NA))
ds$delta.br3 = with(ds, ifelse(!is.na(start3B), delta.br / (1 * !is.na(c("start1B", "start2B", "start3B"))) %*% c(1, 1, 1), NA))
```

Now compute for individual players

```{r}
war.br = ddply(ds, ~ start1B, summarise, PA = length(start1B), G = length(unique(gameId)), RAA = sum(delta), RAA.br = sum(delta.br1 + delta.br2 + delta.br3, na.rm=TRUE))
war.br[order(war.br$RAA.br, decreasing=TRUE),]
densityplot(~RAA.br, data=war.br)
```


#### Estimating Pitching WAR

For right now, let's only consider events where the ball is not in play. 

```{r}
mod.pitch = lm(delta ~ isBIP + stadium + (stand == throws), data=ds)
summary(mod.pitch)
```

```{r}
ds = transform(ds, delta.pitch = mod.pitch$residuals)
war.pitch = ddply(ds, ~ pitcherId, summarise, Name = max(as.character(pitcherName)), PA = length(pitcherId), G = length(unique(gameId)), HR = sum(event=="Home Run"), RAA = sum(delta), RAA.pitch = sum(delta.pitch))
war.pitch[order(war.pitch$RAA.pitch, decreasing=FALSE),]
densityplot(~RAA.pitch, data=war.pitch)
```

#### Estimating Fielding WAR

Who's made the most plays?

```{r}
lkup.b = ds[,c("batterId", "batterName")]
lkup.p = ds[,c("pitcherId", "pitcherName")]
names(lkup.p) = names(lkup.b)
lkup = unique(rbind(lkup.b, lkup.p))
```


```{r}
ds.field = subset(ds, isBIP == FALSE) 
mod.field = lm(delta ~ stadium + stand, data=ds.field)
summary(mod.field)
```

This only measures the plays they made -- not the plays they didn't make!

```{r}
ds.field = transform(ds.field, hat.delta.field = mod.field$residuals)
war.field = ddply(ds.field[,c("gameId", "fielderId", "event", "delta", "hat.delta.field")], ~ fielderId, summarise, N = length(fielderId), G = length(unique(gameId)), RAA.null = sum(delta, na.rm=TRUE), RAA.field = sum(hat.delta.field, na.rm=TRUE))
war.field = merge(x=war.field, y=lkup, by.x = "fielderId", by.y = "batterId", all.x=TRUE)
war.field[order(war.field$RAA.field, decreasing=FALSE),]
densityplot(~RAA.field, data=war.field)
```

```{r}
# form = "poly(our.x, 2) + poly(our.y, 2)"
mod.P = glm((fielderId == pitcherId) ~ as.formula(form) , data=ds.field, family="binomial")
mod.C = glm((fielderId == playerId.C) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
mod.1B = glm((fielderId == playerId.1B) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
mod.2B = glm((fielderId == playerId.2B) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
mod.3B = glm((fielderId == playerId.3B) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
mod.SS = glm((fielderId == playerId.SS) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
mod.LF = glm((fielderId == playerId.LF) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
mod.CF = glm((fielderId == playerId.CF) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
mod.RF = glm((fielderId == playerId.RF) ~ poly(our.x, 2) + poly(our.y, 2), data=ds.field, family="binomial")
summary(mod.SS)

fit.SS = makeFun(mod.SS)
require(gridExtra)
grid.arrange(p4, p6)
print(p4, split=c(1,1,1,2))
print(p6, split=c(1,2,1,2))

p6 = plotFun(fit.SS(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 400))
p4 = plotFun(fit.2B(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 400))
plotFun(fit.LF(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 500))
plotFun(fit.CF(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 500))
plotFun(fit.RF(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 500))
plotFun(fit.1B(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 400))
plotFun(fit.3B(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 400))
plotFun(fit.P(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 400))
plotFun(fit.C(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 400))

fit.P = makeFun(mod.P)
fit.C = makeFun(mod.C)
fit.1B = makeFun(mod.1B)
fit.2B = makeFun(mod.2B)
fit.3B = makeFun(mod.3B)
fit.LF = makeFun(mod.LF)
fit.CF = makeFun(mod.CF)
fit.RF = makeFun(mod.RF)
fit.all = makeFun(fit.P(x, y) + fit.C(x, y) + fit.1B(x, y) + fit.2B(x, y) + fit.3B(x, y) + fit.SS(x,y) + fit.LF(x, y) + fit.CF(x, y) + fit.RF(x,y) ~ x + y)
one = makeFun(1 ~ x + y)
fit = makeFun(min(one(x,y), fit.all(x,y)) ~ x + y)
plotFun(fit(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 500))
```


Fit one surface for all fielders.

```{r}
mod.all = glm(!is.na(fielderId) ~ poly(our.x, 12) + poly(our.y, 12) + our.x * our.y, data=ds.field, family="binomial")
summary(mod.all)
fit.all = makeFun(mod.all)
plotFun(fit.all(x, y) ~ x + y, surface=TRUE, alpha = 1, x.lim = c(-300, 300), y.lim = c(0, 500))
```

#### Final Output

We have our point estimates, but now let's put some variance estimates on those. 

```{r}
warplot(431151, data=ds)
warplot(c(431151, 502517, 408234, 285078), data=ds)
```

