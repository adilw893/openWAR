Sanity Checks
========================================================

Here are a few useful sanity checks for the data compiled by the **openWAR** package. 

```{r, message=FALSE}
require(openWAR)
require(mosaic)
require(plyr)
data(MLBAM2013)
ds = MLBAM2013
```

#### Data Accuracy

First, some basic accounting to make sure that our data is accurate. Compare these with [Baseball-reference.com](http://www.baseball-reference.com/leagues/MLB/2013-standard-batting.shtml)

```{r}
sort(tally(~event, data=ds), decreasing=TRUE)
ds$bat_team = with(ds, ifelse(half == "top", as.character(away_team), as.character(home_team)))
teams = ddply(ds, ~ bat_team, summarise, G = length(unique(gameId)), PA = sum(isPA), R = sum(runsOnPlay), H = sum(isHit), HR = sum(event == "Home Run"), K = sum(event %in% c("Strikeout", "Strikeout - DP")), OBP = sum(isHit | event %in% c("Walk", "Intent Walk", "Hit By Pitch")) / sum(isPA & !event %in% c("Sac Bunt", "Sacrifice Bunt DP")))
teams[order(teams$OBP, decreasing=TRUE),]
```

These numbers are *very* close. 

#### Modeling the Expected Runs Matrix (REM)

In this case we have ``r nrow(ds)`` observations. However, not all of these innings were completed, due to walk-offs. By including these innings, we would be underestimating the expected run values, since those walk-off innings score fewer runs than they potentially could have. 

```{r}
walk.offs = ddply(subset(ds, outsInInning < 3, select=c("gameId", "inning", "half")), ~gameId + inning + half, nrow)
walk.offs
```

There were ``r nrow(walk.offs)``, all of which occurred in the bottom of an inning after the 8th. Let's remove these half-innings

```{r}
ds.complete = subset(ds, outsInInning == 3)
```


These break down by state as follows:

```{r}
rmod1 = favstats(runsFuture ~ as.factor(startCode) + as.factor(startOuts), data=ds.complete)
rmod1
```

The number of complete innings is:

```{r}
N = nrow(unique(ds.complete[,c("gameId", "inning", "half")]))
N
nrow(subset(ds.complete, startCode == 0 & startOuts == 0 & runsITD == 0))
nrow(subset(ds.complete, endCode == 0 & endOuts == 3))
```

Thus, in the empirical model for $runsFuture$, the value of the state $(0,0)$ is:

```{r}
rmod1$mean[1]
```

Alternatively, consider a regression model for $runsFuture$ as a function of $startCode$ and $startOuts$ and their interaction:

```{r, eval=TRUE}
rmod2 = lm(runsFuture ~ as.factor(startCode) * as.factor(startOuts), data=ds.complete)
summary(rmod2)
fit.rem = makeFun(rmod2)
```

We can use this model to recover a Run Expectancy Matrix, similar to [this one](http://www.baseballprospectus.com/sortable/index.php?cid=1091223) computed by Baseball Prospectus from 2012. 

> Note that our notation for the baseCode is different from theirs. 

```{r}
states = expand.grid(startCode = 0:7, startOuts = 0:2)
states = transform(states, runs = predict(rmod2, newdata=states))
rem = matrix(states$runs, ncol = 3, dimnames=list(0:7, 0:2))
rem
```

Compare these figures with the empirical estimates

```{r}
matrix(rmod1$mean, ncol = 3, dimnames=list(0:7, 0:2))
```

The coefficients are the same, but the regression framework gives us a principled way to address the error in these estimates. We can also visualize our model. 

```{r}
xyplot(jitter(runsFuture) ~ jitter(startCode), groups=startOuts, data=ds.complete
       , alpha = 0.3, pch = 19
       , auto.key=list(columns = 3)
       , xlab="Base Code before Plate Appearance"
       , ylab="Runs Following Plate Appearance"
)
palette = trellis.par.get("superpose.symbol")$col
ladd(panel.lines(row.names(rem), rem[,1], col = palette[1], lwd = 3))
ladd(panel.lines(row.names(rem), rem[,2], col = palette[2], lwd = 3))
ladd(panel.lines(row.names(rem), rem[,3], col = palette[3], lwd = 3))
```

We note that in general, each higher $baseCode$ is associated with a larger number of expected $futureRuns$, holding the number of $outs$ constant. We can see this more clearly by looking simply at the model estimates. 

```{r}
xyplot(runs ~ startCode, groups=startOuts, data=states
       , type=c("p", "l"), auto.key=list(columns = 3)
       , xlab="Base Code before Plate Appearance"
       , ylab="Expected Runs Following Plate Appearance"
)
```

It is also instructive to examine the distribution of runs scored **on** (not $futureRuns$, but rather $runsOnPlay$) a particular plate appearance. 

```{r}
xyplot(jitter(runsOnPlay) ~ jitter(startCode), groups=startOuts, data=ds.complete
       , auto.key=list(columns = 3)
       , xlab="Base Code before Plate Appearance"
       , ylab="Runs Generated by Plate Appearance"
)
```

#### Conservation of Expected Runs

We employ the notion of **conservation of runs**. That is, every run gained by the offense is a run lost by the defense. Thus, our first task is to determine, for each play, how many *expected* runs were gained by the offensive team. The defensive team must have lost that same number of *expected* runs. Let $r_i$ be actual number of runs scored on the $i^{th}$ play, and $\rho(b,o)$ be the true expected value of the state $(b,o)$. Then we define 
$$
  \delta_i = \rho(b_{i+1},o_{i+1}) - \rho(b_i,o_i) + r_{i}
$$
to be the true number of expected runs gained on the $i^{th}$ play. We stress that this quantity is unknown, since we can only estimate the true expected value associated with each $(base, out)$ state. 

One of the nice features of this type of model is that in $n$ completed innings, the number of expected runs generated should be exactly equal to the number of runs scored. 

$$
  \sum_{j \in innings} \sum_{i \in plays} \delta_{i}^j = \sum_{j \in innings} \sum_{i \in plays} \rho^j(b_{i+1}, o_{i+1}) - \rho^j(b_{i}, o_{i}) + r_{i}^j 
$$
$$
  = \sum_{j \in innings} \rho (0, 3) - \rho (0,0) + \sum_{i \in plays} r_i^j = - n \cdot \rho(0,0) + \sum_{j \in innings} \sum_{i \in plays} r_i^j
$$
This leads us to the estimate that
$$
  \hat{\rho}(0,0) = \frac{1}{n} \sum_{j \in innings} \sum_{i \in plays} r_i^j
$$

If runs are conserved, then the sum of all of the $\delta_i$'s should be zero.

```{r makingWAR}
ds = makeWAR(ds)
ds.complete = subset(ds, outsInInning == 3)
sum(ds.complete$delta)
```

Moreover, the total number of runs scored should match the product of the number of completed innings times $\hat{\rho}(0,0)$. 

```{r}
sum(ds.complete$runsOnPlay)
N * fit.rem(0,0)
```

Note that the runs are not equally distributed across innings. The first inning is by far the most favorable to the offense (positive expected runs created), while the 9th inning is most favorable to the defense (closer pitching). 

```{r, message=FALSE}
require(plyr)
ddply(ds, ~ inning, summarise, N = length(inning), G = length(unique(gameId)), D = sum(delta, na.rm=TRUE))
```

#### The Balance of Power

Note that by definition, the RAA's for each of the four components will be zero. 

```{r}
sum(ds$raa.bat)
sum(ds$raa.br)
sum(ds$raa.pitch)
sum(ds$raa.field)
```

However, this same property does **not** hold for the $\delta$'s. 

```{r}
sum(ds$delta.bat)
sum(ds$delta.br1, na.rm=TRUE) + sum(ds$delta.br2, na.rm=TRUE) + sum(ds$delta.br3, na.rm=TRUE)
sum(ds$delta.pitch)
sum(ds$delta.field, na.rm=TRUE)
```

However, the offensive and defensive $\delta$'s are perfectly balanced. 

```{r}
sum(ds$delta.bat) + sum(ds$delta.br1, na.rm=TRUE) + sum(ds$delta.br2, na.rm=TRUE) + sum(ds$delta.br3, na.rm=TRUE)
sum(ds$delta.pitch) + sum(ds$delta.field, na.rm=TRUE)
```
